// Checks if an array contains a value x
function contains(array, x) {
    for (var i = 0; i < array.length; i++) {
        if (array[i] === x) {
            return true;
        }
    }
    return false;
}

// Checks if a point is equal to another point (same x and y coordinates)
var Point = { equals : function(p1, p2) {
    return ((p1.x == p2.x) && (p1.y == p2.y)) }}

// The points list with an add function (cascading enabled)
var pointList = {
  points : new Array(),
  addPoint : function(p){
    this.points[this.points.length] = p;
    return this;
  }
}

// Adds to both the adjacent points lists of the two points
function makeAdjacentPoints(p1, p2){
  if (contains(p1.adjacentPoints, p2)) { return; }
  if (Point.equals(p1, p2)) { return; }
  p1.adjacentPoints[p1.adjacentPoints.length] = p2.label;
  p2.adjacentPoints[p2.adjacentPoints.length] = p1.label;
}
/*
// Finds the distance between two points
function distance(p1, p2){
  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
}
*/

//Taken from http://www.movable-type.co.uk/scripts/latlong.html
//Gets the distance in metres between two coordinates
function distance(p1, p2) {

	function toRad(deg) {
		return deg * Math.PI / 180;
	}

	lat1 = p1.y; lon1 = p1.x;
	lat2 = p2.y; lon2 = p2.x;

	var R = 6371; // km
	var dLat = toRad(lat2-lat1);
	var dLon = toRad(lon2-lon1);
	var lat1 = toRad(lat1);
	var lat2 = toRad(lat2);

	var a = Math.sin(dLat/2) * Math.sin(dLat/2) +
			Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2); 
	var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
	var d = R * c;
	
	return d * 1000;
}

// Clones a path object (needed for recursion)
function clone(pathTracker){
  var temp = {};
  temp.points = new Array();
  temp.distance = pathTracker.distance;
  for (var i = 0; i < pathTracker.points.length; i++){
    temp.points[i] = pathTracker.points[i];
  }
  return temp;
}

exports.latLngToXY = function (point) {

	if( "geometry" in point) {
		point.x = point.geometry.coordinates[0];
		point.y = point.geometry.coordinates[1];
		
		return true;
	}
	else {
		return false;
	}
}

function printArray(array){
  for (var i = 0; i < array.length; i++){
    console.log(array[i]);
  }
}

// Finds the direction and returns a string associated with that direction
function direction(p1, p2){
  if (p2.x == p1.x) return "north";
  var dy = p2.y - p1.y;
  var dx = p2.x - p1.x;
  
  answer = (Math.atan2(dy,dx)) * 180 / 3.1415; // Finds the angle of the line
  // Get out of here negatives
  if (answer < 0) answer += 360;
  
  // This controls the direction which is chosen based on the angle of the line made by the two points
  if (answer >=0){
    if (answer < 30) return "east";
	if (answer < 60) return "neast";
	if (answer < 120) return "north";
	if (answer < 150) return "nwest";
	if (answer < 210) return "west";
	if (answer < 240) return "swest";
	if (answer < 300) return "south";
	if (answer < 330) return "seast";
	if (answer < 361) return "east";
  }
  return "badvalue";
}

// Assumes that the path object passed in has a list of objects with x and y values
// Finds the directions required to travel through the path
function findDirections(path){
  var directionArray = new Array();
  
  for (var i = 0; i < path.length - 1; i++){
    directionArray[i] = direction(path[i], path[i+1]);
  }
    
  return directionArray;

} 

// Finds all the paths between p1 and p2. Returns an empty array with distance of 0 if there does not exist a path
// To access the point array, use [object][index].points. For example:
// var paths = findPath(p1,p2);
// To access the points of the path, use paths[0].points
// To acces the distance, use paths[0].distance
function findPath(p1, p2, pointList){
  
  for (var i = 0; i < pointList.length; i++){
    for (var j = 0; j < pointList[i].adjacentPoints.length; j++){
	  for (var k = 0; k < pointList.length; k++){
	    if (pointList[i].adjacentPoints[j] == pointList[k].label){
		  pointList[i].adjacentPoints[j] = pointList[k];
		}
	  }
	}
  }
  
  var allPaths = new Array(); // Keeps track of all the paths
  var minDist = 500*distance(p1, p2);
  
  function helper(pathTracker, currP, dest, dist){ // The recursive calling function
    if (currP.visited){ return; } // If the point has been visited before, don't do anything
    pathTracker.points[pathTracker.points.length] = currP; // Otherwise add the point to the path tracker
    pathTracker.distance += dist; // And add the distance travelled to get to the point
	
	if (pathTracker.distance > minDist) return;
	
    if (Point.equals(currP, dest)) { // If we have reached the destination
      if (pathTracker.distance > minDist) return;
	  minDist = pathTracker.distance;
	  allPaths[0] = clone(pathTracker); // Add the path to the path array and return, needs to clone the path tracker because the path tracker is used in all recursion steps
	  pathTracker.points.pop();
	  pathTracker.distance -= dist;
      return;
    }

    currP.visited = true;
    for (var i = 0; i < currP.adjacentPoints.length; i++){ // Calls the path finding algorithm on each adjacent point
                                                                    // Clone of the path is to prevent passing by reference (will change if too slow
      helper(clone(pathTracker), currP.adjacentPoints[i], dest, distance(currP, currP.adjacentPoints[i]));
    }
	
	pathTracker.points.pop();      // After a point has been gone over, it does not longer belong on the path tracker
	pathTracker.distance -= dist;
    currP.visited = false; // After all it's points have been recursed on, reinitialize the visited value to false
  } // HELPER FUNCTION FINISHED

  helper({ points : new Array(), distance : 0 }, p1, p2, 0); // Calls the recursive function initally
  
  allPaths.print = function(){ // Adds a print function to the list of paths being returned
    for (var i = 0; i < allPaths.length; i++){
      console.log("Path:", i+1);
      console.log("Distance: ", allPaths[i].distance);
      console.log("Path taken: ");

      for (var j = 0; j < allPaths[i].points.length; j++){
        console.log("Point ", allPaths[i].points[j].label, " to");
      }
      console.log(); console.log();
    }
  }
  allPaths[0].directions = convertDirections(findDirections(allPaths[0].points));
  return allPaths; // Returns the list of paths
}

function convertDirections(directions) {
	var readableDirections = [];

	readableDirections[0] = "Go into the tunnels";
	
	for(var i = 1; i < directions.length; i++) {
		if(directions[i-1] === "east") {
			if(directions[i] === "south" || directions[i] === "seast" || directions[i] === "swest") {
				readableDirections[i] = "Turn right";
			}
			else if(directions[i] === "north" || directions[i] === "neast" || directions[i] === "nwest") {
				readableDirections[i] = "Turn left";
			}
			else if(directions[i] === "east") {
				readableDirections[i] = "Continue forward";
			}
			else if(directions[i] === "west") {
				readableDirections[i] = "Go backwards...kind of...";
			}
		}
		else if(directions[i-1] === "south") {
			if(directions[i] === "west" || directions[i] === "nwest" || directions[i] === "swest") {
				readableDirections[i] = "Turn right";
			}
			else if(directions[i] === "east" || directions[i] === "neast" || directions[i] === "seast") {
				readableDirections[i] = "Turn left";
			}
			else if(directions[i] === "south") {
				readableDirections[i] = "Continue forward";
			}
			else if(directions[i] === "north") {
				readableDirections[i] = "Go backwards...I think...";
			}
		}
		else if(directions[i-1] === "west") {
			if(directions[i] === "north" || directions[i] === "neast" || directions[i] === "nwest") {
				readableDirections[i] = "Turn right";
			}
			else if(directions[i] === "south" || directions[i] === "seast" || directions[i] === "swest") {
				readableDirections[i] = "Turn left";
			}
			else if(directions[i] === "west") {
				readableDirections[i] = "Continue forward";
			}
			else if(directions[i] === "east") {
				readableDirections[i] = "Go backwards...I think...";
			}
		}
		else if(directions[i-1] === "north") {
			if(directions[i] === "east" || directions[i] === "neast" || directions[i] === "seast") {
				readableDirections[i] = "Turn right";
			}
			else if(directions[i] === "west" || directions[i] === "nwest" || directions[i] === "swest") {
				readableDirections[i] = "Turn left";
			}
			else if(directions[i] === "north") {
				readableDirections[i] = "Continue forward";
			}
			else if(directions[i] === "south") {
				readableDirections[i] = "Go backwards...I think...";
			}
		}
		else if(directions[i-1] === "neast") {
			if(directions[i] === "east" || directions[i] === "seast" || directions[i] === "south") {
				readableDirections[i] = "Turn right";
			}
			else if(directions[i] === "north" || directions[i] === "nwest" || directions[i] === "west") {
				readableDirections[i] = "Turn left";
			}
			else if(directions[i] === "neast") {
				readableDirections[i] = "Continue forward";
			}
			else if(directions[i] === "swest") {
				readableDirections[i] = "Go backwards...I think...";
			}
		}
		else if(directions[i-1] === "seast") {
			if(directions[i] === "south" || directions[i] === "swest" || directions[i] === "west") {
				readableDirections[i] = "Turn right";
			}
			else if(directions[i] === "east" || directions[i] === "neast" || directions[i] === "north") {
				readableDirections[i] = "Turn left";
			}
			else if(directions[i] === "seast") {
				readableDirections[i] = "Continue forward";
			}
			else if(directions[i] === "nwest") {
				readableDirections[i] = "Go backwards...I think...";
			}
		}
		else if(directions[i-1] === "swest") {
			if(directions[i] === "west" || directions[i] === "nwest" || directions[i] === "north") {
				readableDirections[i] = "Turn right";
			}
			else if(directions[i] === "south" || directions[i] === "seast" || directions[i] === "east") {
				readableDirections[i] = "Turn left";
			}
			else if(directions[i] === "swest") {
				readableDirections[i] = "Continue forward";
			}
			else if(directions[i] === "neast") {
				readableDirections[i] = "Go backwards...I think...";
			}
		}
		else if(directions[i-1] === "nwest") {
			if(directions[i] === "north" || directions[i] === "neast" || directions[i] === "east") {
				readableDirections[i] = "Turn right";
			}
			else if(directions[i] === "west" || directions[i] === "swest" || directions[i] === "south") {
				readableDirections[i] = "Turn left";
			}
			else if(directions[i] === "nwest") {
				readableDirections[i] = "Continue forward";
			}
			else if(directions[i] === "seast") {
				readableDirections[i] = "Go backwards...I think...";
			}
		}
	}
	
	return readableDirections;
}

exports.findPath = findPath;
exports.distance = distance;